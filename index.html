<!doctype html>
<html>
	<head>
		<link href="styles.css" rel="stylesheet" type="text/css" />
		<script src="Phys.js" type="text/javascript"></script>
		<script src="Phys.predict.js" type="text/javascript"></script>
	</head>
	<body>
		<canvas id="view" width="300" height="300" style="border:2px inset";></canvas>
		<div id="controls">
			<button id="relaunch">Relaunch</button>
			Bounce = <span id="bounce-display">1</span><br />
			<input id="bounce" type="range" min="0.01" max="1" value="1" step="0.01" />
		</div>

		<script type="text/javascript">
			var raf = function() { };
			var raf = requestAnimationFrame;

			var view = document.getElementById("view"),
				vctx = view.getContext("2d"),
				vw = view.width, vc = vw/2, vh = view.height;

			var fullCircle = Math.PI * 2, radius = 20, clearPadding = 1;
			var scale = 80, bounce = 0.5, atRest = false;

			var ball = new Phys();
			ball.onGround = vh - radius;
			ball.bounce = 0.5;
			ball.reset = function() {
				var scale = 80;
				ball.position=ball.onGround;
				ball.velocity=-7.5 * 80;
				ball.acceleration = 9.8 * 80;
				
				onGround.next();
				console.log(onGround.time);
				
				vctx.fillStyle="red";
			};
			
			var onGround = {
				next: function() {
					return (onGround.time = Phys.predict.time.byPosition(ball, ball.onGround));
				},
				time: null
			};

			ball.reset();
			
			raf((function(){
				var prevFrame = Date.now(),
					nextFrame, deltaFrame, avgFrame;
				
				var bounces = 0;
				return function frame() {
					nextFrame=Date.now();
					deltaFrame = (nextFrame - prevFrame)/1000;
					prevFrame=nextFrame;
					
					{ // update
						//console.log(onGround.time);
						if(onGround.time!==null){
							while ((onGround.time!==null) && (onGround.time<deltaFrame)) {
								ball.simulate(onGround.time);
								//console.log(++bounces, "bounce from", ball.position, onGround.time, deltaFrame);
								ball.velocity = -ball.velocity * ball.bounce;
							
								deltaFrame -= onGround.time;
								onGround.next();
							}
							
							if(onGround.time>deltaFrame){
								ball.simulate(deltaFrame);
								onGround.time-=deltaFrame;

								if (onGround.time < avgFrame) {
									console.log("pre-calc next onGround");
									onGround.next();
								}
							}
						}
					}
					
					{ // render
						vctx.clearRect(0,0,vw,vh);

						vctx.beginPath();
						vctx.arc(vc, ball.position, radius, 0, fullCircle, true);
						vctx.fill();
					}
					
					raf(frame);
				};
			})());

			(function setupBounceInput() {
				var display = document.getElementById("bounce-display");
				
				var input = document.getElementById("bounce");
				input.addEventListener("input", update);
				input.addEventListener("change", update);
				function update() {
					if(ball.bounce!=input.value){
						display.innerText = input.value;
						ball.bounce=+input.value;
						if(onGround.time===null){
							ball.reset();
						}
					}
				}
			})();
			
			document.getElementById("relaunch").addEventListener("click", function(){
				var oldPos = ball.position, atRest = (onGround.time === null);
				ball.reset();
				//debugger;
				if(!atRest){
					var moveToPosition = Phys.predict.time.byPosition(ball, oldPos);
					console.log(moveToPosition);
					ball.simulate(moveToPosition);
					onGround.next();
				}
			});
		</script>
	</body>
</html>